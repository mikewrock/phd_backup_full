\chapter{Background}
\label{chap:background}
\section{Literature Review}
\label{sec:litreview}
\subsection{Robot Localization}
\label{sec:localiz}
\subsection{Trajectory Generation}
\label{sec:traj}
\subsection{Thickness Estimation}
\label{sec:thick}
\section{ROS: The Robot Operating System}
\label{sec:ros}

ROS first emerged in 2007 from a company called Willow Garage as they adapted software originally developed in Stanford's Artificial Intelligence Laboratory. Development continued and in 2009 the first paper on ROS was published \cite{rosfirst}, ROS.org was launched, and the first tutorials were released. In 2010 the first official version ROS 1.0 was released followed by 11 more versions over the next 7 years as well as development of the next generation of ROS, called ROS 2. As of 2017, there are 9395 unique packages available for users to download, implement, modify or use in any way allowed under the BSD license \cite{http://download.ros.org/downloads/metrics/metrics-report-2017-07.pdf}.\\

ROS is middleware designed specifically for robotics. It is a software framework that allows users to create software in a variety of programming languages suck as C++, Python, and Lisp. Software packages written for ROS can include nodes, message types, configuration files, and function libraries. The foundation of a ROS package is usually the nodes that are written for it. ROS nodes are software programs written in C++, Python, or Lisp for use within the ROS framework. The nodes are responsible for performing the required robotics task. Nodes can communicate with each other regardless of what language they are written in. Multiple nodes can be run on a single machine, or many machines can be used with one or more nodes running on each one.\\

Nodes use the ROS framework to communicate with each other by publishing messages and subscribing to topics. Figure \ref{fig:rosmessage} shows a simple diagram of how two ROS nodes may communicate with each other. In this example, Node 1 is a ``Publisher'' and publishes a message to the topic ``Topic 1''. Node 2 is a ``Subscriber'' and subscribes to all messages published to the ``Topic 1'' topic. Node perform the actions of sending and receiving messages when they ``Spin''. When a publisher spins, any messages waiting to be published to a topic is published. When a subscriber spins it will look at all the topics it is subscribed to and execute the corresponding callback function. Whenever a node subscribes to a topic, a callback function must be defined. This function is executed when a ROS message is retrieved from a topic, usually processing the received message in some way. ROS messages contain data that can be divided in to four categories: built-in datatypes, other message types, arrays, or headers. The built-in datatypes are commonly used datatypes like booleans, strings, floats, and integers of various precision. For example, when creating a message to describe a student, one might use a string for their name, an integer for their student ID, and a float for their GPA (or an array of floats to store grade points from each course they've taken). If one were to make a message to describe a classroom, they could include a string for the course name, an integer for the maximum capacity, and use an array of ``student'' messages to contain information of all the students in the class. A ``header'' is a message that so commonly used it is treated as it's own datatype. Headers are usually included in a message because they contain a unique ID, time-stamp, and frame-id. The frame-id is particularly useful in mobile robotics, and helps organize all the possible frames of reference in a project by naming each one.\\

Figure \ref{fig:roscomplex} shows a more complex utilization of the ROS framework. In this example Node 3 and Node 4 run on a separate machine, but the ROS framework allows them all to communicate seamlessly as if they were on a single machine. As shown in Figure \ref{fig:roscomplex} nodes can publish to one or multiple topics (Node 1 and Node 2), subscribe to multiple topics (Node 4), or both publish and subscribe to one or more topics (Node 3). The topics are simply named channels for nodes to send and receive messages along.\\

The ROS ``Master'' is a special node that enables the core functionality of ROS. It is never modified by the user, and must always be run before executing ROS nodes. The master node allows nodes to find each other, exchange messages, and invoke services. Services are used when bidirectional communication between nodes is necessary. If a node structure like that shown in Figure \ref{fig:rosservicelong} is needed, a ROS service can be implemented instead (as shown in Figure \ref{fig:rosservice}). A service will advertise it's name using the ROS master, and nodes can invoke the service with request/response message pairs. When a service is called it is passed a request message, and when it completes it returns a response message. Services are created just like nodes, and can also publish and subscribe to topics as well as performing the service they advertise. Actions are very similar to services, but provide periodic updates as they are executing and can be preempted. An example usage for a service would be to generate a shotcrete spraying trajectory. A node would send a pointcloud message representing the mine surface to the trajectory service, and the service would send and arm trajectory message in response. An action could be used to execute the arm trajectory, where a node would send the arm trajectory as a goal, and the action would complete the motion. While the arm is moving, the action could provide feedback on the current position of the arm. At completion the action can provide a result, like a boolean for success, triggering another action to be performed.\\

The master node is also used to store information on the parameter server. The parameter server is a central location for ROS nodes to store and retrieve data. Data stored on the parameter server is usually values that do not change often. Nodes can place or retrieve data from the parameter server, which is often used for various configuration settings. Any node can retrieve this information for their own use or modify it for use by other nodes. An example usage of the parameter server is to customize shotcrete spray patterns. Values like shotcrete flowrate, via-point distance, sprayer velocity, and surface offset can all be stored on the parameter server. When a shotcrete spraying trajectory is requested, the service can read the relevant specifications from the parameter server. A user can directly change the values on the parameter server, it can be loaded from a file, or modified by another node during runtime.\\

ROS can also record communication across topics using ``bags''. A rosbag is a file with the ``.bag'' extension and hold all the messages sent across a given topic or topics. This tool is particularly useful in simulations based on existing data. A ROS bag file can be recorded on a laser scan topic as a robot drives around. The bag file can then be played back while a mapping algorithm is running to produce a map. Using a bag file, many different mapping algorithms can be developed and tested without having to physically drive the robot every time.\\

Typical execution of a ROS package begins in the terminal window. The terminal window is a command line interface to the operating system. From there nodes can be run, services launched, parameter server values changed, and many other ROS specific features. A launch file has the extension ``.launch'' and provides a convenient way of launching multiple nodes and services at once as well as loading multiple sets of configuration parameters. Using a launch file, all of the command line entries to launch and configure a ROS package can be executed using a singe command. The syntax of a launch file follows the Extensible Markup Language (XML) formatting rules, which makes the document readable to both humans and machines. Launch files can be configured to launch when the computer system starts up, what means an operator need only provide power to the system and it can begin running any software packages it has been assigned to launch.\\