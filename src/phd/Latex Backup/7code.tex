\chapter{Software}
\label{chap:code}
\section{Chapter Summary}
This chapter discusses the complete ROS package built and presents the algorithms used in the MASS source code. Much of the code simply facilitates the handling and communication of data across the various nodes as well as inputting and parsing commands from the user. Since the system was primarily designed to be a research platform many of the testing, debugging, and experimentation portions of the code have been included in the final version for future work. The ROS package contains typical elements such as \node{CMakeLists.txt}, \node{package.xml}, messages, services, configuration and launch files, URDF descriptions, source code, and headers. The following sections discuss the package framework and core functionality using pseudo code algorithms. The complete code can be found in Appendix \ref{app:code}. Beginning with a discussion of the ROS framework this chapter presents the novel algorithms developed for this work.\\
\section{Package Files}

A package is the most atomic structure in ROS, meaning it is the root of all projects created for ROS. At its minimum, a package is simply a directory containing \node{package.xml}. As the package grows to contain its own software nodes, a \node{CMakeLists.txt} file is used to define which software files need to be compiled. Other components of a ROS package can include messages, services, dependencies, header files, and source code. Packages big and small are all self contained so they can be easily shared and implemented on other systems.\\

\subsection{package.xml}
The file \node{package.xml} contains the package name, version number, description, maintainer, and license. As well, it contains a list of all the other packages necessary to build and run the package. It contains a reference to \node{plugin_description.xml} so the compiler is aware there are custom plugins for this package and what file they are located in.\\

The \node{package.xml} for the MASS can be found in Appendix \ref{app:pack}.
\subsection{plugin\_description.xml}
This package uses a custom plugin and tool for RViz. The plugin, called ``Control Panel'' is a ``ControlPanel'' object in the ``control\_panel'' namespace and extends the ``RViz::Panel'' class. The ``Selection Tool'' tool is a fork of the ``SelectionTool'' class called ``selection\_tool'' and extends the ``RViz::Tool'' class. It has been modified to function more effectively when used with the MASS GUI.\\

The \node{plugin_description.xml} for the MASS can be found in Appendix \ref{app:plug}.
\subsection{CMakeLists.txt}
The \node{CMakeLists.txt} file is the first file ROS uses when compiling the package. Within this file all the nodes, messages, services, configuration files, and dependencies are declared. They can be found listed in Table \ref{tab:cmakelists}. The file can be found in Appendix \ref{app:cmake}.\\
\begin{table}[h!]
\begin{adjustwidth}{-.5in}{-.5in}  
\begin{tabular}{|c|c|c|c|}
\hline
Nodes & Messages & Services & Configuration Files \\ \hline
\parbox[t]{4cm}{
\tabitem cube\_node \\
\tabitem denso\_node \\
\tabitem joint\_fusion\_node \\
\tabitem cloud\_localizer \\
\tabitem thickness\_server \\
\tabitem trajectory\_server \\} & \parbox[t]{4cm}{
\tabitem cube\_msg \\
\tabitem arm\_msg \\
\tabitem trajectory\_point \\
\tabitem trajectory\_msg \\
\tabitem trajectory\_array \\
\tabitem empty \\} & \parbox[t]{4cm}{
\tabitem localize\_cloud \\
\tabitem thickness\_service \\
\tabitem trajectory\_service \\} & \parbox[t]{4cm}{
\tabitem param\_config \\
\tabitem localize\_config \\
\tabitem trajectory\_config \\}\\ \hline
\end{tabular}
\caption[]{Contents of \node{CMakeLists.txt}}
\label{tab:cmakelists}
\end{adjustwidth}
\end{table}
\section{Launch Files}
Two launch files are provided: \node{main.launch} and \node{simulation.launch}. The launch files appear in their entirety in Appendix \ref{app:launch} and are explained as follows: 

\subsection{main.launch}

The \node{main.launch} file performs the following actions (using the syntax \node{package_name} : \node{node_name}):
\begin{itemize}

\item Include other launch files

\begin{itemize}

\item \node{MASS_husky_description} : \node{description.launch}
\item \node{husky_control} : \node{control.launch}
\item \node{husky_control} : \node{teleop.launch}

\end{itemize}

\item Launch nodes
\begin{itemize}

\item \node{MASS} : \node{cube_node}
\item \node{MASS} : \node{denso_node}
\item \node{MASS} : \node{joint_fusion}
\item \node{um6} : \node{um6_driver}
\item \node{move_base} : \node{move_base}
\item \node{lms1xx} : \node{LMS1xx_node}
\item \node{laser_filters} : \node{scan_to_scan_filter_chain}
\item \node{laser_assembler} : \node{laser_scan_assembler}
\item \node{hector_mapping} : \node{hector_mapping}
\item \node{RViz} : \node{RViz}
\item \node{rqt_reconfigure} : \node{rqt_reconfigure}
\item \node{tf} : \node{static_transform_publisher}

\end{itemize}

\item Launch services

\begin{itemize}

\item \node{MASS} : \node{cloud_localizer}
\item \node{MASS} : \node{trajectory_server}
\item \node{MASS} : \node{thickness_server}

\end{itemize}

\item Load configuration files

\begin{itemize}

\item \node{MASS} : \node{RViz_main.RViz}
\item \node{MASS} : \node{my_laser_config.yaml}
\item \node{husky_navigation} : \node{planner.yaml}
\item \node{husky_navigation} : \node{costmap_common.yaml}
\item \node{husky_navigation} : \node{costmap_local.yaml}
\item \node{husky_navigation} : \node{costmap_global_laser.yaml}
\end{itemize}

\end{itemize}

Since the MASS is a modified Husky UGV, the URDF description has been modified accordingly. A separate package for the modified URDF description called \node{MASS_husky_description} was made and the launch file containing the URDF description is included. Including a launch file within another launch file effectively copies all the code from the included launch file into the main launch file, but keeping them separate allows the user to keep the package modular and makes the launch file more compact and readable.\\

Following the inclusion of the URDF launch file, the Husky specific nodes are launched. The node responsible for communication between ROS and the Husky is called \node{husky_node}. When launched the parameters indicating which USB port it is connected to, the controller and diagnostic frequencies, wheel diameter, and speed and acceleration limits are set. Launch files from the \node{husky_control} package are included to instruct the controller how to properly handle \node{move_base} velocity and joystick commands, perform EKF localization, and display the Husky's movements in RViz. As well, the driver for the IMU on board the Husky is launched.\\

When the \node{move_base} node is launched the local and global planner configurations are loaded from a file or stated explicitly. Parameters like the Husky footprint size and recovery behaviours are not intended to be modified frequently, so they are stored in a file. The user may want to change other parameters like maximum velocity and the safety buffer from obstacles, or have multiple launch files with different settings. They are able to set or overwrite parameters from a configuration file explicitly in the launch file. Whether the parameters are set using a configuration file or from the launch file the effect is the same, however, the launch file takes priority so if the same parameter is set using both methods, the values in the launch file will be used.\\

When the \node{scan_to_scan_filter} node is launched it loads the configuration file that sets the LiDAR distance, intensity, and angular range to be used. As well, the LiDAR driver and \node{laser_scan_assembler} node is launched.\\

The \node{powercube}, \node{denso}, and \node{joint_fusion} nodes are launched to publish the joint states of the robot. The \node{joint_fusion} node combines the individual joint states from the other two nodes and publishes them as a single joint state message. The node \node{robot_state_publisher} uses the joint state message and the URDF file to publish the tf tree of the robot. The tf tree, as its name implies, is a tree structure of coordinate frame transformations. It is used by ROS to calculate the transformation between any two frames present and is used by RViz along with the URDF to display the current pose of the MASS and its manipulator.\\

The node \node{hector_mapping} performs SLAM while the robot is operating. When launched, the parameter for \var{base_frame} is set so it has a point of reference for its local coordinate frame.\\

When RViz is launched, ``RViz\_MASS.RViz'' is loaded to configure the RViz environment optimally for use with the MASS. Different ``.RViz'' files can be loaded for different scenarios, for example the ``RViz\_debug.RViz'' configuration is loaded when debugging because it displays many of the point clouds and visualizations that are helpful in debugging but unnecessary during normal operation.\\

The final section of the launch file launches the trajectory generation, localization, and thickness estimation services, the \node{rqt_reconfigure} GUI, and a \node{static_transform_publisher} that aligns the map to the world coordinate frame.\\

\subsection{simulation.launch}

For demonstration, experimentation, or debugging purposes, the user may want to launch an environment where they can use the MASS control panel in RViz with the localization, trajectory generation, and thickness estimation services without connecting to the physical robot. The \node{simulation.launch} file allows the user to do so by launching the following nodes and files:

\begin{itemize}

\item \node{MASS_husky_description} : \node{description.launch}
\item \node{MASS} : \node{joint_fusion}
\item \node{MASS} : \node{cloud_localizer}
\item \node{MASS} : \node{trajectory_server}
\item \node{MASS} : \node{thickness_server}
\item \node{RViz} : \node{RViz}
\item \node{MASS} : \node{RViz_debug.RViz}
\item \node{rqt_reconfigure} : \node{rqt_reconfigure}
\item \node{tf} : \node{static_transform_publisher}
\end{itemize}

\section{Messages}

Messages are a convenient way of grouping together variables into a single object. In this work, messages are used to send commands from \node{control_panel} to \node{denso_node} and \node{cube_node}. As well, custom messages were generated for use in determining the fiducial marker location and transmitting arm trajectories between nodes.\\

\subsection{trajectory\_point.msg}
\includecode{CleanedCode/msg/trajectory_point.msg}{trajectory\_point.msg}
Each point in the trajectory requires the position and surface normal at that position. The \var{trajectory_point} message contains that information as well as a \var{d} parameter. The \var{d} parameter is used when sorting lines of points to keep track of the approximate total distance along the surface (see Section \ref{sec:sortlines}).\\
\subsection{trajectory\_msg.msg}
\label{sec:trajmsg}
\includecode{CleanedCode/msg/trajectory_msg.msg}{trajectory\_msg.msg}
Messages in ROS can contain a limited variety of datatypes, but among them is the ability to include other messages or arrays of messages (see \url{http://wiki.ros.org/msg}). For the manipulator trajectories in this work, an array of \var{trajectory_point} messages is used.\\

\subsection{arm\_msg.msg}
\includecode{CleanedCode/msg/arm_msg.msg}{arm\_msg.msg}
The \node{arm_msg} message was designed to make it easy to send commands to the DENSO manipulator. The message contains 32-bit floats that can hold joint positions, XYZ positions (and the rotation around each axis), velocity, and acceleration. The \var{fig} integer allows the user to command the desired shoulder, elbow, and wrist configuration (\var{fig} table can be found in Appendix \ref{sec:fig}). The \var{pose} boolean is used to tell \node{denso_node} whether the XYZ values are positions or velocities. Since the DENSO manipulator can perform continuous path motion as well as point-to-point, the \var{motion_type} variable holds the desired motion behaviour. For testing and debugging purposes it may become necessary to manually generate a command string to send to the DENSO controller, so the string \var{user_string} was added to incorporate that functionality.\\

\subsection{cube\_msg.msg}
\includecode{CleanedCode/msg/cube_msg.msg}{cube\_msg.msg}
Originally the \node{cube_node} was designed to handle multiple Powercubes at once, but as research continued, the Powercube manipulator was replaced with the DENSO manipulator. Additional joint variables can easily be added should a user want to control multiple Powercubes, however, control of a single Powercube is all that is required within this work. The variables in the \var{cube_msg} message contain the desired position or velocity (depending on the value of \var{pose}), the maximum velocity (used only in position commands), and maximum acceleration allowed to reach the position (or velocity) goal.\\

\subsection{marker\_val.msg}
\includecode{CleanedCode/msg/marker_val.msg}{marker\_val.msg}
When the localization algorithm attempts to detect the markers, it is possible there may be many potential keypoints to choose from, meaning multiple marker candidates exist. The \var{marker_val} message is used to hold them so a sorting algorithm can find the closest match in the marker file. The i, j, and k variables hold the position of the first, second, and third keypoint within the array of keypoint candidates. The \var{val} variable holds a value representing how accurately the keypoints match the recorded keypoints in the marker file. The value for \var{val} is calculated using a weighted sum of the the distances between $P_1-P_2$, $P_2-P_3$, and the angle between $\mathbf{P_1P_2}$ and $\mathbf{P_2P_3}$. \\

\section{Services}
In ROS services are able to receive and return variables and messages. In order for ROS to determine what messages or variables to expect and what to return, a ``.srv'' file is used to explicitly declare the messages a service is expecting and what message it will return. The division between incoming and outgoing data is marked by a line containing ``\texttt{----}''. The three services built for this work are the ``Cloud Localization Service'', ``Trajectory Generation Service'', and ``Thickness Estimation Service'' discussed below, their source code can be found in Appendix \ref{app:sourcesrv}.\\
\subsection{Cloud Localization Service}
\includecode{CleanedCode/srv/localize_cloud.srv}{localize\_cloud.srv}
This localization service expects a point cloud to localize, a string to indicate the location of the marker file, and a boolean used to instruct the service if the point cloud scan is to set the world coordinate frame or localize within it. The service returns the localized cloud and a transformation matrix from the robot's frame of reference to the marker's frame.\\
%
%\lstinputlisting[
%style=C++style,
%caption={[pointcloud\_localization\_service.cpp (lines 86, 91, and 100)] pointcloud\_localization\_service.cpp (lines 86, 91, and 100)},
%linerange={86-86,91-91,100-100},]{CleanedCode/src/pointcloud_localization_service.cpp}
  
Three helper functions were used to simplify the main portions of the code. They perform dot products, cross products, and normalized cross products. The main function initializes the node, advertises its service on the \node{\localize_pcd} topic, and configures a visualization to show the possible marker keypoint locations on topic \node{\visualization_marker}. The \node{rqt_reconfigure} callbacks are set and the visualization marker style is set. The node then ``spins'', meaning it will wait until a message is received and execute the appropriate callback. A callback function ROS was written for each topic the service subscribes to.\\

The callback function to localize the cloud is explained in Algorithm \ref{alg:localize}.
\begin{algorithm}[H]
\caption{Localization Algorithm}
\label{alg:localize}
\begin{algorithmic}[1]
\begin{raggedright}
\Function{localize}{Input cloud, Marker filename, Homing boolean}
\State Filter incoming point cloud based on user-defined maximum and minimum intensity values
\If {User requests homing scan}
\State Change input point cloud coordinate frame from \node{base_footprint} to \node{world}
\Else
\State Open marker.bag file to retrieve markers
\State Cluster point cloud points to generate list of keypoint candidates
\State Determine which keypoint candidates correspond to marker keypoints
\State Select best marker (based on correspondence)
\State Transform input point cloud to world coordinate frame \EndIf
\EndFunction\\
\Return Localized point cloud
\end{raggedright}
\end{algorithmic}
\end{algorithm}

\subsubsection{Clustering Points}
Since the LiDAR scanner's resolution is smaller than the size of the marker keypoint, it will typically detect multiple data points per marker keypoint. The keypoint candidates are determined by taking the mean location of all data points within a certain radius and with sufficiently high reflected intensity. The algorithm to cluster data points into keypoint candidates is Algorithm \ref{alg:cluster} (note, the data has already been filtered for intensity so all data points remaining are possible marker keypoints).

\begin{algorithm}[H]
\caption{Clustering Algorithm}
\label{alg:cluster}
\begin{algorithmic}[1]
\algnotext{EndFor}
\begin{raggedright}
\Function{cluster}{Intensity filtered input cloud}
\ForAll{Points in input cloud}
\If{Intensity $>0$}
\State Add point to clustering array
\ForAll{Remaining points in input cloud}
\If{Distance between points is less than CLUSTER\_DISTANCE \textbf{AND} Intensity $>0$}\\
\Comment{CLUSTER\_DISTANCE set by user using rqt\_reconfigure}
\State Add point to clustering array
\State Set point intensity to 0 (so it doesn't get added to another cluster)
\EndIf
\EndFor
\State Average all points in clustering array
\State Add averaged point to array of keypoint candidates
\State Clear clustering array
\EndIf
\EndFor
\EndFunction\\
\Return Array of keypoint candidates
\end{raggedright}
\end{algorithmic}
\end{algorithm}
\subsubsection{Determining Marker Keypoints}
After the clustering algorithm, an array of keypoint candidates is produced. If there are less than three points, the marker has not been detected and the service reports a failure. If there are three or more keypoint candidates, they must be checked to ensure they fit the marker model. If there are multiple groups of keypoint candidates that fit the marker model, the best fit is chosen. If none of the keypoints fit the marker model, the service reports it could not detect the marker. Once the marker is located, a $3\times3$ matrix holding the XYZ positions of the marker keypoints and a $4\times4$ transformation matrix of its position relative to the scanner is stored in the matrices indicated by the pointers passed to the function. The algorithm for fitting keypoint candidates and selecting the best three is Algorithm \ref{alg:keypoint}.
\begin{spacing}{0.8}
\begin{algorithm}[H]
\caption{Keypoint Selection Algorithm}
\label{alg:keypoint}
\begin{algorithmic}[1]
\algnotext{EndFor}
\begin{raggedright}
\Function{locate\_marker}{Array of keypoint candidates, Marker file location, Pointer to return transformation martix}
\State Clear marker\_found boolean
\For{$ i:=1 $ \textbf{to} Size of candidate array}
\For{$ j:=1 $ \textbf{to} Size of candidate array}
\For{$ k:=1 $ \textbf{to} Size of candidate array}
\If{$i\neq j\neq k$}
\State Calculate distances between $i$, $j$, and $k$
\State Calculate dot product between vector $\mathbf{ji}$ and $\mathbf{jk}$
\For{Each marker in the marker file}
\State Calculate accuracy by comparing distances and dot product to marker file
\EndFor
\State Store $i$, $j$, $k$, accuracy, and marker index in array of marker candidates
\If{Marker candidate is within user defined accuracy limits}
\State Set marker candidate as valid
\If{Valid marker candidate already exists}
\State Set optimization flag
\EndIf
\EndIf
\EndIf
\EndFor
\EndFor
\EndFor
\If{One or more marker candidates are found}
\State Set marker\_found boolean
\If{Optimization flag is set}
\State Select most accurate candidate
\EndIf
\State Calculate and return transformation matrix using the indicated pointer \
\EndIf
\EndFunction\\
\Return Boolean indicating if marker was located
\end{raggedright}
\end{algorithmic}
\end{algorithm}
\end{spacing}
The code for calculating the transformation matrix (where P1, P2, and P3 correspond to $i$, $j$, and $k$ from algorithm \ref{alg:keypoint}) can be found in Appendix \ref{app:tmat}.\\

\subsection{Trajectory Generation  Service}
\includecode{CleanedCode/srv/trajectory_service.srv}{trajectory\_service.srv}
The trajectory generation service expects two point clouds and returns a \var{trajectory_msg} formatted trajectory (see Section \ref{sec:trajmsg}). The first point cloud, called \var{cloud_in}, is the area to generate a trajectory for. The second point cloud, \var{cloud_surface}, is the entire scan. The full surface scan is required for calculating surface normals at the edge of the selected area, since without it only a portion of the surrounding data points would be used to calculate the surface normal.\\

When the service launches it advertises itself on the \node{/trajectory_gen} topic. It then configures the publishers responsible for displaying the markers that show the end-effector path, surface path, surface normals, via points within the workspace, and via points outside the workspace. Finally it configures the callback for \node{rqt_reconfigure}. Once initialized, the service waits to be called upon.\\

When the service is called, it executes the ``generate()'' function. The trajectory is generated in two stages, the first is for vertical sections and the second is for horizontal (overhead) sections as per Algorithms \ref{alg:trajv} and \ref{alg:trajh}.
\begin{algorithm}[H]
\caption{Trajectory Generation Algorithm (Vertical Sections)}
\label{alg:trajv}
\begin{algorithmic}[1]
\algnotext{EndFor}
\begin{raggedright}
\Function{generate}{Point cloud selection, Full point cloud}
\State Extract intersection between horizontal plane (at \var{mid_height}) and point cloud selection
\State Sort extracted line (at \var{chunk_radius} downsampling)
\For{$ ctr:=1 $ \textbf{to} Size of sorted line}
\State Extract intersection between vertical plane (passing through robot centre and point of sorted line at index \var{ctr}) and point cloud selection
\State Sort extracted line (at \var{downsample_radius} downsampling)
\State Add extracted line to \var{rib_array}
\EndFor
\State Set \var{height} = 0
\While{\var{height} < (\var{wall_height} \textbf{and} max height of point cloud selection)}
\For{$ ctr:=1 $ \textbf{to} Size of \var{rib_array}}
\State Select point at \var{height} in rib at index \var{ctr} of \var{rib_array}
\State Calculate point normal (using full point cloud), apply offset, and add point to \var{arm_trajectory}
\EndFor
\State Increment \var{height} by \var{height_step}
\For{$ ctr:=$ Size of \var{rib_array} \textbf{to} $1$}
\State Select point at \var{height} in rib \var{ctr} of \var{rib_array}
\State Calculate point normal, apply offset, and add point to \var{arm_trajectory}
\EndFor
\If{\var{height} > (\var{wall_height} \textbf{or} max height of point cloud selection)}
\State Break while loop
\EndIf
\State Increment \var{height} by \var{height_step}
\EndWhile
\EndFunction\\
\Return Arm Trajectory
\end{raggedright}
\end{algorithmic}
\end{algorithm}
\begin{spacing}{0.8}
\begin{algorithm}[H]
\caption{Trajectory Generation Algorithm (Horizontal Sections)}
\label{alg:trajh}
\begin{algorithmic}[1]
\algnotext{EndFor}
\begin{raggedright}
\Function{generate}{Point cloud selection, Full point cloud}
\State Extract intersection between vertical plane (through robot's X-axis) and point cloud selection
\If{No intersection exists}
\State Extract intersection between vertical plane (through robot's Y-axis) and point cloud selection
\EndIf
\If{No intersection exists}
\State Extract intersection between vertical plane (parallel with robot's X-axis, but intersecting nearest point in point cloud selection
\EndIf 
\State Sort extracted line (at \var{chunk_radius} downsampling)
\For{$ ctr:=1 $ \textbf{to} Size of sorted line}
\State Rotate a horizontal plane around robot's Y-axis (or X-axis) to intersect with point \var{ctr} of sorted line
\State Extract intersection between rotated plane and point cloud selection
\State Sort extracted line (at \var{downsample_radius} downsampling)
\State Add extracted line to \var{rib_array}
\EndFor
\State \var{height} = \var{wall_height}
\While{\var{height} < max height of point cloud selection (measured along the surface)}
\For{$ ctr:=1 $ \textbf{to} Size of \var{rib_array}}
\State Select point at \var{height} in rib \var{ctr} of \var{rib_array}
\State Calculate point normal, apply offset, and add point to \var{arm_trajectory}
\EndFor
\State Increment \var{height} by \var{height_step}
\For{$ ctr:=$ Size of \var{rib_array} \textbf{to} $1$}
\State Select point at \var{height} in rib \var{ctr} of \var{rib_array}
\State Calculate point normal, apply offset, and add point to \var{arm_trajectory}
\EndFor
\If{\var{height} > max height of point cloud selection (measured along the surface)}
\State Break while loop
\EndIf
\State Increment \var{height} by \var{height_step}
\EndWhile
\EndFunction\\
\Return Arm Trajectory
\end{raggedright}
\end{algorithmic}
\end{algorithm}
\end{spacing}
\subsection{Thickness Estimation Service}

The thickness estimation service is fairly simple and straightforward. For each point in the source cloud the nearest neighbour is found in the target cloud. The intensity value of that data point is replaced with the value of the distance to the nearest neighbour. The service automatically saves the calculated point cloud to a file. For the most accurate results, it is best to choose the point cloud with the highest point density as the target cloud.\\

The algorithm for calculating shotcrete thickness is Algorithm \ref{alg:thick}.

\begin{algorithm}[H]
\caption{Thickness Estimation Algorithm}
\label{alg:thick}
\begin{algorithmic}[1]
\algnotext{EndFor}
\begin{raggedright}
\Function{calculate}{Source point cloud, Target point cloud}
\ForAll{Points in source}
\State Find nearest point in target
\State Calculate distance between points
\State Replace point's intensity value with absolute distance measured
\EndFor
\State Save point cloud to disk
\EndFunction\\
\Return Point cloud with thickness values
\end{raggedright}
\end{algorithmic}
\end{algorithm}

\subsection{Map Reset Service}
The Hector SLAM package does not have the functionality to halt the mapping process. It also does not support 3D mapping so it will not take in to account the rotation of the LiDAR's nodding head. This means that when the nodding head moves to generate a point cloud, the SLAM algorithm will attempt to interpret the new laser scan data as robot motion, most often ending up distorting the map and losing its position. For this reason, the map must be reset after every point cloud scan. The Hector SLAM package can reset the map upon receiving an empty service call on the \node{move_base/clear_costmaps} topic, so the message ``empty.srv'' was generated to perform such actions. Before each reset the map is saved to disk so SLAM can resume after the scan is taken.\\

\section{Configuration Files}
Configuration files used by the \node{rqt_reconfigure} node make the parameters within them available for modification through the \node{rqt_reconfigure} GUI. A configuration file contains the variables' name, data type, priority level, and text description as well as the default, maximum, and minimum value. The configuration files for this work can be found in Appendix \ref{app:cfgs}.\\

The control panel configuration file (ROS File \ref{code:cpcfg} in Appendix \ref{app:cfgs}) generates an interface in the \node{rqt_reconfigure} GUI which can be seen in Figure \ref{fig:cpgui}. The variable names are seen on the left of the slider bars, with the maximum and minimum values on the right and left side of the slider respectively. To the right of the slider bars, the user can manually enter in a number instead of using the slider. When the user hovers the mouse over a variable, the text description appears in a black box (as shown for the ``init\_clear'' parameter in Figure \ref{fig:cpgui}).

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{Pics/control_panel.png}
    \caption{\texttt{rqt\_reconfigure} GUI for Control Panel Parameters}
    \label{fig:cpgui}
\end{figure}

\subsection{YAML Files}
Files with the .yaml extension are used for parameters that should be easily changed, but do not require modification during runtime. For example, the data from the laser scanner is filtered before being used to create point clouds. Due to the range of motion of the nodding head and the angular bounds of the laser scanner, it is capable of detecting portions of the robot to which it is mounted. This data can be cropped out at a later time, but it is more efficient to limit the distance, angle, and intensity values of the LiDAR data so that the \node{laser_scan_assembler} node does not have to handle as much data. The ROS File \ref{code:yaml} in Appendix \ref{app:cfgs} shows the .yaml configuration file for the \node{scan_filter_chain} node that sets the minimum distance, maximum angle, and maximum intensity values to keep.\\

\section{URDF}
The Unified Robot Description Format (URDF) is an XML format for representing a robot model. A URDF file representing the system in this work can be found in Appendix \ref{app:urdf}. The Graphviz diagram for visualizing the URDF model can be seen in Figure \ref{fig:urdf}. In the URDF file each link within the robot is given a name. The links are shown in Figure \ref{fig:urdf} as black boxes. The links are then connected with joints (either revolute or prismatic), shown as blue ellipses in Figure \ref{fig:urdf}. The position and orientation of each link is specified in the URDF, as well as the 3D mesh for visualizing the links. With a complete URDF, ROS only requires the angle (or extension) of each joint in order to display a 3D rendered model of the robot within RViz. The \node{robot_state_publisher} node listens for the joint angles and broadcasts the tf tree containing the coordinate frame transformations for each link.\\

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{Pics/urdf.png}
    \caption{Graphviz Diagram of URDF File}
    \label{fig:urdf}
\end{figure}

\section{Header Files}
Header files are often used to define various global functions and variables to be made available to the corresponding source files that include it. These globals can be made public or private, restricting or allowing them to be accessed by other programs. The two source files requiring custom headers are \node{control_panel.cpp} and \node{control_dashboard.cpp}. As well, the \node{marker_selector} plugin has a custom header file for its internal functionality. The header files can be found in Appendix \ref{app:headers}.\\

\section{Source Files}
The main component of the source code for this work is the control panel. The \node{control_dashboard} is embedded as a panel in RViz and creates the QNode object \node{control_panel}. The reason for this configuration is modularity; if the control panel is to be moved out of the RViz environment, \node{control_panel} is left unchanged and \node{control_dashboard} is replaced with a standalone container for the GUI. The complete code for all source files can be found in Appendix \ref{app:source}.
\subsection{Control Dashboard}
The \node{control_dashboard} node was designed as an RViz panel with the intention to make it replaceable should the designer decide to develop a standalone application instead of using RViz as the environment for the GUI. To mimimize the amount of work required to convert the panel to a standalone application, as little code as possible was implemented in the node.\\

The dashboard performs the actions that an operator would during manual control. When the robot is finished taking a scan, the dashboard instructs \node{control_panel} to generate a trajectory. Upon completion of the shotcrete application or radiation scan the dashboard instructs \node{control_panel} to advance the robot to complete its task if required. After arriving at its new location the dashboard instructs the robot to begin a scan and generate a trajectory. The GUI layout uses \node{control_dashboard} to call the appropriate \node{control_panel} functions when the GUI buttons are pressed, meaning all commands are passed through \node{control_dashboard}.\\
\subsection{Control Panel}
The \node{control_panel} node is the central controller of the system. It is responsible for executing the commands that are passed to it through \node{control_dashboard}. This node performs the following tasks:
\begin{itemize}
\item Visualization
\begin{itemize}
\item Default Shotcrete Region
\item Auto-crop Region
\item Move\_base Goal
\item Laser Scanned Point Clouds
\item Manipulator Workspace
\item Trajectory Display
\begin{itemize}
\item Surface Path
\item End-effector Path
\item Surface Normal
\item Via Points Within Manipulator Workspace
\item Via Points Outside Manipulator Workspace
\end{itemize}
\end{itemize}
\item Calling Services
\begin{itemize}
\item Laser Assembler
\item Localization
\item Trajectory Generation
\item Thickness Estimation
\item Map Reset
\end{itemize}
\item Publishing Motion Commands
\begin{itemize}
\item Powercube (Nodding Head)
\item DENSO (Manipulator)
\item Husky (Base)
\end{itemize}
\item Administrative Functions
\begin{itemize}
\item Set World Coordinate Frame
\item Save Point Cloud Selection
\item Load Trajectory From File
\item Step Through Via Points
\item Software Emergency Stop
\item Set Manipulator Speed
\item Manually Initiate Laser Scan
\item Record Marker Location
\item Load Point Cloud From File
\end{itemize}
\item Internally Used Functions
\begin{itemize}
\item Delete Point From Point Cloud
\item Find and Delete Nearest Neighbour
\item Delete Points Within Area
\item Calculate Vector Length
\item Calculate Dot Product
\item Calculate Manipulator Roll, Pitch, and Yaw for a Given Surface Normal
\item Move Via Point to Workspace
\item Find and Publish New Base Goal Location
\end{itemize}
\end{itemize}
\subsubsection{Visualization}
Figures \ref{fig:cropb} to \ref{fig:cands} show the visualizations that \node{control_panel} generates. The default area the robot will apply shotcrete to is shown in teal in Figure \ref{fig:cropb}. Since the scanner can capture some of the robot body when generating point clouds, it is useful to automatically crop a region that is likely to contain the robot but unlikely to contain sections of the mine surface. The auto-crop region is shown in orange in Figure \ref{fig:cropb}. For debugging purposes, the user may want to be aware of the keypoint candidates the localization algorithm is using, so they are published as translucent red boxes as seen in Figure \ref{fig:cands}. When a trajectory is generated many of the via points must be moved to within the manipulator's workspace due to its small size. The points that must be moved are shown as red points in Figure \ref{fig:trajviz} and the points that lie within the workspace are shown in green.\\
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{Pics/cropboxespng.png}
    \caption{Auto-crop (Orange) and Auto-shotcrete (Teal) Area Visualizations}
    \label{fig:cropb}
\end{figure}
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{Pics/workspace.png}
    \caption{Visualization of DENSO Workspace}
    \label{fig:worksp}
\end{figure}
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{Pics/traj_viz.png}
    \caption{Trajectory Vizualization: Surface Path (Red), End-Effector Path (Green), Surface Normal (Blue), Via Points Within Manipulator Workspace (Green), and Via Points Outside Manipulator Workspace (Red)}
    \label{fig:trajviz}
\end{figure}
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{Pics/candidates.png}
    \caption{Potential Keypoint Candidates Highlighted (Red)}
    \label{fig:cands}
\end{figure}
\subsubsection{Administrative Functions}
\label{sub:admin}
Most of the administrative functions are functions that are used internally during autonomous mode. When manually controlling the robot, they can be controlled directly. Through the use of administrative functions, the operator can manually drive the robot to a location of their choosing, perform a scan (and either set the location as the world coordinate frame or localize the cloud within it), generate a trajectory, load a trajectory or point cloud from file, step through the via points one at a time, set the manipulator speed, or initiate a software E-Stop (emergency stop) command. \\

The \node{control_panel} is also responsible for recording the marker location. The process of recording a marker is presented in Section \ref{sec:manual}. Internally, \node{control_panel} will calculate the marker parameters and store them in a file for use during localization.\\
\subsubsection{Internal Functions}
In order to perform the required tasks, several internally used functions were created. The ``Delete Point From Point Cloud'', ``Find and Delete Nearest Neighbour'', and ``Delete Points Within Area'' are used together to remove sections of a point cloud or line of points. These functions essentially downsample the point cloud but remove the downsampled points as they are used.\\

Since the manipulator workspace is small, it is difficult to test if the trajectory execution is successful. For this reason a function that moves via points outside the workspace to within the workspace is used. This function will move points too far for the manipulator to reach without losing degrees-of-freedom to the edge of the dextrous workspace. At that point, rather than using the surface normal, the end-effector aims in the direction defined by the vector from the workspace centre to the new via point location. As well, there is a wedge shaped region directly behind the manipulator base which it cannot reach, so points located within that region are moved inside the workspace as well. These actions are performed with the help of the vector length function.\\

The manipulator requires Roll-Pitch-Yaw (RPY) angles to define the end-effector orientation, so \node{control_panel} calculates the corresponding RPY at each via point based on the surface normal. To calculate the RPY, a dot product function is used. While there are dot product functions available through the Eigen software library, they require different data types, so a modified dot product function was used instead of performing data type conversions on the input and output values of the Eigen dot product function.\\

Once the MASS has completed scanning or shotcreting the area within its workspace, it may be required to advance the base to a new location to complete the scanning or shotcreting process. It does so using Algorithm \ref{alg:findandmove}.

\begin{algorithm}[H]
\caption{Base Advance Algorithm}
\label{alg:findandmove}
\begin{algorithmic}[1]
\State Acquire point cloud of surroundings
\State Extract a horizontal line from the point cloud at \var{mid_height}
\State Crop any points that are within the area that was already scanned or shotcreted
\State Crop an area the size of the workspace, centred at the nearest remaining point
\State Determine surface normal at nearest remaining point, using original point cloud for normal calculation
\State Define \node{move_base} goal using desired offset from wall
\State Define \node{move_base} orientation using cross product between Z-axis and surface normal
\State Publish \node{move_base} goal and visualization marker
\end{algorithmic}
\end{algorithm}

\subsection{DENSO and Powercube Nodes}
The DENSO node is the software interface between the DENSO controller and the ROS package. The node communicates with the DENSO controller via ethernet using the bCAP communication protocol and WINCAPSIII formatted messages. Once a connection has been established the node activates the remote operation task loaded on the controller and begins sending commands. After initialization, the node waits for an \node{arm_msg} message and sends the appropriate commands to the controller to achieve the desired manipulator motion. When not sending commands to the manipulator, it is reading the manipulator's current pose so it can broadcast the data for other nodes to receive such as the \node{robot_state_publisher} responsible for displaying the 3D model of the robot in RViz\\

The Powercube node sends commands through a virtual serial port created by the USB-Serial adapter connected to the system. Similar to the DENSO node, it initializes the device and waits for \node{cube_msg} messages to instruct it to move the Powercube to the desired position. Like the DENSO node, it also continually broadcasts the position of the Powercube.\\
 
\subsection{Additional Nodes}
To follow the data flow structure of this package a modified version of RViz's Selection Tool was used. The modifications allow the tool to broadcast a point cloud message containing the selected points. This point cloud message is used by the various services and nodes that require user input (such as marker selection or area to shotcrete).\\

The \node{robot_state_publisher} node that provides the tf tree of the system was designed to have a single source broadcasting the joint states over the \node{/joint_states} topic. However, in this work there are three separate sources for joint states: the Husky, the DENSO manipulator, and the Powercube module. To fuse the three separate joint state messages the \node{joint_state_fusion} node subscribes to all three sources and broadcasts a single message containing the pose of all the links in the system.\\
\section{External Packages and Libraries}
\label{sec:extpkg}
Some of the nodes in this work use messages or functions created for other packages. In order for the nodes to use them, they must be added as a dependency to the package. The dependencies in this work are:

\begin{itemize}
\item roscpp
\item rospy
\item RViz
\item sensor\_msgs
\item std\_msgs
\item tf
\item urdf 
\item diagnostic\_updater
\item schunk\_libm5api
\item diagnostic\_msgs
\item control\_msgs
\item message\_generation
\item message\_filters
\item actionlib\_msgs
\item laser\_assembler
\item pcl\_conversions 
\item pcl\_ros 
\item MASS\_husky\_description
\item qt\_build
\item dynamic\_reconfigure
\end{itemize}