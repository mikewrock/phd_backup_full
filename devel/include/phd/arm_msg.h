// Generated by gencpp from file phd/arm_msg.msg
// DO NOT EDIT!


#ifndef PHD_MESSAGE_ARM_MSG_H
#define PHD_MESSAGE_ARM_MSG_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace phd
{
template <class ContainerAllocator>
struct arm_msg_
{
  typedef arm_msg_<ContainerAllocator> Type;

  arm_msg_()
    : j1(0.0)
    , j2(0.0)
    , j3(0.0)
    , j4(0.0)
    , j5(0.0)
    , j6(0.0)
    , x(0.0)
    , y(0.0)
    , z(0.0)
    , rx(0.0)
    , ry(0.0)
    , rz(0.0)
    , vel(0.0)
    , acc(0.0)
    , fig(0)
    , pose(false)  {
    }
  arm_msg_(const ContainerAllocator& _alloc)
    : j1(0.0)
    , j2(0.0)
    , j3(0.0)
    , j4(0.0)
    , j5(0.0)
    , j6(0.0)
    , x(0.0)
    , y(0.0)
    , z(0.0)
    , rx(0.0)
    , ry(0.0)
    , rz(0.0)
    , vel(0.0)
    , acc(0.0)
    , fig(0)
    , pose(false)  {
  (void)_alloc;
    }



   typedef float _j1_type;
  _j1_type j1;

   typedef float _j2_type;
  _j2_type j2;

   typedef float _j3_type;
  _j3_type j3;

   typedef float _j4_type;
  _j4_type j4;

   typedef float _j5_type;
  _j5_type j5;

   typedef float _j6_type;
  _j6_type j6;

   typedef float _x_type;
  _x_type x;

   typedef float _y_type;
  _y_type y;

   typedef float _z_type;
  _z_type z;

   typedef float _rx_type;
  _rx_type rx;

   typedef float _ry_type;
  _ry_type ry;

   typedef float _rz_type;
  _rz_type rz;

   typedef float _vel_type;
  _vel_type vel;

   typedef float _acc_type;
  _acc_type acc;

   typedef int32_t _fig_type;
  _fig_type fig;

   typedef uint8_t _pose_type;
  _pose_type pose;




  typedef boost::shared_ptr< ::phd::arm_msg_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::phd::arm_msg_<ContainerAllocator> const> ConstPtr;

}; // struct arm_msg_

typedef ::phd::arm_msg_<std::allocator<void> > arm_msg;

typedef boost::shared_ptr< ::phd::arm_msg > arm_msgPtr;
typedef boost::shared_ptr< ::phd::arm_msg const> arm_msgConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::phd::arm_msg_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::phd::arm_msg_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace phd

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': True, 'IsMessage': True, 'HasHeader': False}
// {'sensor_msgs': ['/opt/ros/indigo/share/sensor_msgs/cmake/../msg'], 'actionlib_msgs': ['/opt/ros/indigo/share/actionlib_msgs/cmake/../msg'], 'std_msgs': ['/opt/ros/indigo/share/std_msgs/cmake/../msg'], 'geometry_msgs': ['/opt/ros/indigo/share/geometry_msgs/cmake/../msg'], 'phd': ['/home/mike/catkin_ws/src/phd/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::phd::arm_msg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::phd::arm_msg_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::phd::arm_msg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::phd::arm_msg_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::phd::arm_msg_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::phd::arm_msg_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::phd::arm_msg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "0bb97e20ed067fe2635824700ced1b68";
  }

  static const char* value(const ::phd::arm_msg_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x0bb97e20ed067fe2ULL;
  static const uint64_t static_value2 = 0x635824700ced1b68ULL;
};

template<class ContainerAllocator>
struct DataType< ::phd::arm_msg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "phd/arm_msg";
  }

  static const char* value(const ::phd::arm_msg_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::phd::arm_msg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float32 j1\n\
float32 j2\n\
float32 j3\n\
float32 j4\n\
float32 j5\n\
float32 j6\n\
float32 x\n\
float32 y\n\
float32 z\n\
float32 rx\n\
float32 ry\n\
float32 rz\n\
float32 vel\n\
float32 acc\n\
int32 fig\n\
bool pose\n\
\n\
";
  }

  static const char* value(const ::phd::arm_msg_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::phd::arm_msg_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.j1);
      stream.next(m.j2);
      stream.next(m.j3);
      stream.next(m.j4);
      stream.next(m.j5);
      stream.next(m.j6);
      stream.next(m.x);
      stream.next(m.y);
      stream.next(m.z);
      stream.next(m.rx);
      stream.next(m.ry);
      stream.next(m.rz);
      stream.next(m.vel);
      stream.next(m.acc);
      stream.next(m.fig);
      stream.next(m.pose);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct arm_msg_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::phd::arm_msg_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::phd::arm_msg_<ContainerAllocator>& v)
  {
    s << indent << "j1: ";
    Printer<float>::stream(s, indent + "  ", v.j1);
    s << indent << "j2: ";
    Printer<float>::stream(s, indent + "  ", v.j2);
    s << indent << "j3: ";
    Printer<float>::stream(s, indent + "  ", v.j3);
    s << indent << "j4: ";
    Printer<float>::stream(s, indent + "  ", v.j4);
    s << indent << "j5: ";
    Printer<float>::stream(s, indent + "  ", v.j5);
    s << indent << "j6: ";
    Printer<float>::stream(s, indent + "  ", v.j6);
    s << indent << "x: ";
    Printer<float>::stream(s, indent + "  ", v.x);
    s << indent << "y: ";
    Printer<float>::stream(s, indent + "  ", v.y);
    s << indent << "z: ";
    Printer<float>::stream(s, indent + "  ", v.z);
    s << indent << "rx: ";
    Printer<float>::stream(s, indent + "  ", v.rx);
    s << indent << "ry: ";
    Printer<float>::stream(s, indent + "  ", v.ry);
    s << indent << "rz: ";
    Printer<float>::stream(s, indent + "  ", v.rz);
    s << indent << "vel: ";
    Printer<float>::stream(s, indent + "  ", v.vel);
    s << indent << "acc: ";
    Printer<float>::stream(s, indent + "  ", v.acc);
    s << indent << "fig: ";
    Printer<int32_t>::stream(s, indent + "  ", v.fig);
    s << indent << "pose: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.pose);
  }
};

} // namespace message_operations
} // namespace ros

#endif // PHD_MESSAGE_ARM_MSG_H
